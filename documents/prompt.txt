You are a senior Solidity + Hardhat engineer. Build a 1:1 USD-backed stablecoin per the spec below. Work incrementally with tight feedback: after EACH step, run tests, verify build, and output a short changelog plus NEXT ACTIONS checklist. Never hardcode secrets or addresses. Read all config ONLY from .env via a central loader that switches by NODE_ENV. If anything is ambiguous, choose the safest, most standard option and document it in README.md.

GOAL
- Upgradeable ERC-20 “Vetra” (symbol VTR), 18 decimals, UUPSUpgradeable + AccessControl.
- Roles: DEFAULT_ADMIN_ROLE (governance), MINTER_ROLE, BURNER_ROLE. Upgrades only by admin.
- Operators can mint/burn. Emit TokensMinted and TokensBurned.
- Integrate Chainlink Functions to fetch FT Asset Management proof-of-reserves and anchor on-chain.
- Enforce freshness: reserve TTL 15 min; updates target every 5 min.
- Optional safeties: Pausable; per-tx mint limit; allowlist for mint recipients.
- Observability: rich events; scripts for monitoring.
- Deploy first on Polygon Amoy, then Polygon mainnet. Switch networks by editing ONLY NODE_ENV in .env.
- Deliverables: contracts, Hardhat scripts, unit+integration tests, docs, Polygonscan verification.

NETWORKS
- Testnet: Polygon Amoy (chainId 80002).
- Mainnet: Polygon PoS (chainId 137).
- Link + Functions config must be read from .env for each network. Do not hardcode addresses.

GOVERNANCE & OPERATORS
- Mainnet admin: 0x29F1bE1E72c031539bc22437aFde22fF765EE00e
- Mainnet MINTER/BURNER: 0x308442BBd27CAF66c614471Fb1933f7dd447b5da
- Testnet admin/minter/burner: developer EOA from .env (don’t assume it equals mainnet).
- Upgrades: UUPS _authorizeUpgrade restricted to DEFAULT_ADMIN_ROLE.

RESERVE SOURCE (Chainlink Functions)
- Source API (placed in .env, not hardcoded):
  https://my.ftassetmanagement.com/api/bcl.asp?KeyCodeGUID=f9132e91-d810-11ef-a3af-00155d010b18&AccountGUID=d2e45a89-7de0-11f0-8b61-00155d010b18&AccountNr=42528
- Use Chainlink Functions to fetch and parse numeric USD reserve (document exact JSON fields in README).
- Store: lastReserveUsd (uint256, 8 decimals of USD precision or cents—pick one, document), lastReserveTimestamp, lastReserveNonce.
- Freshness: any mint requires block.timestamp - lastReserveTimestamp <= TTL (900s).
- Monotonicity: require incoming nonce > lastReserveNonce on fulfill.
- Events: ReserveUpdateRequested(requestId), ReserveUpdated(usd, nonce, timestamp).

SUPPLY INVARIANT
- Enforce 1:1: totalSupply() + amountToMint <= lastReserveUsdScaled.
- Scaling rule: define RESERVE_SCALE (e.g., USD with 6 or 8 decimals) and conversion to 18-decimals token. Document clearly and test edge cases.

REPO STRUCTURE
- contracts/
  - Vetra.sol                (ERC20Upgradeable, UUPSUpgradeable, AccessControlUpgradeable, PausableUpgradeable)
  - oracle/VetraReserve.sol  (FunctionsClient or integrated in Vetra if cleaner; pick one and document)
  - libs/MathUtils.sol       (safe scaling helpers)
- scripts/
  - deploy.ts                (proxy deploy, role setup per env)
  - updateReserve.ts         (kick off Functions request on demand)
  - verify.ts                (Polygonscan verification for impl + proxy via OZ plugin)
  - monitor.ts               (read events, pretty-print)
- test/
  - vetra.core.spec.ts
  - vetra.roles.spec.ts
  - vetra.upgrade.spec.ts
  - vetra.reserve.spec.ts
  - vetra.limits.spec.ts
- config/
  - env.ts                   (central loader choosing AMOY_* vs POLYGON_* by NODE_ENV)
- README.md

TECH STACK
- Node 20+, pnpm or yarn.
- Hardhat + @nomicfoundation/hardhat-toolbox
- @openzeppelin/contracts-upgradeable ^5
- @openzeppelin/hardhat-upgrades
- Chainlink Functions packages (latest stable)
- Typescript
- ESlint + Prettier

.ENV SCHEMA (single file; switch by NODE_ENV only)
# Core
NODE_ENV=development            # or production
PRIVATE_KEY_DEV=0x...           # testnet deployer
POLYGONSCAN_API_KEY=SQFCTQ8UVHUN883CFCNVWZF8SF4QVVJSRY

# Amoy (testnet)
AMOY_RPC_URL=
AMOY_CHAIN_ID=80002
AMOY_LINK_TOKEN=
AMOY_FUNCTIONS_ROUTER=
AMOY_DON_ID=
AMOY_SUBSCRIPTION_ID=          # if using Functions Subscription
AMOY_ADMIN_ADDRESS=${PRIVATE_KEY_DEV_EOA_IF_NEEDED}
AMOY_MINTER_ADDRESS=${PRIVATE_KEY_DEV_EOA_IF_NEEDED}
AMOY_BURNER_ADDRESS=${PRIVATE_KEY_DEV_EOA_IF_NEEDED}

# Polygon mainnet
POLYGON_RPC_URL=
POLYGON_CHAIN_ID=137
POLYGON_LINK_TOKEN=
POLYGON_FUNCTIONS_ROUTER=
POLYGON_DON_ID=
POLYGON_SUBSCRIPTION_ID=
POLYGON_ADMIN_ADDRESS=0x29F1bE1E72c031539bc22437aFde22fF765EE00e
POLYGON_MINTER_ADDRESS=0x308442BBd27CAF66c614471Fb1933f7dd447b5da
POLYGON_BURNER_ADDRESS=0x308442BBd27CAF66c614471Fb1933f7dd447b5da

# Reserve + policy
RESERVE_API_URL=...
RESERVE_UPDATE_INTERVAL_SECONDS=300
RESERVE_TTL_SECONDS=900
MINT_PER_TX_LIMIT=0            # 0 = disabled
ALLOWLIST_ENABLED=false

ENV SWITCHING LOGIC
- config/env.ts chooses the active prefix by NODE_ENV. No other file reads raw process.env.
- All addresses, routers, DON IDs, etc come from env.ts helpers like getLinkToken(), getRouter(), getAdmin().

CONTRACT REQUIREMENTS
Vetra.sol
- initialize(name="Vetra", symbol="VTR").
- grant DEFAULT_ADMIN_ROLE to admin address from constructor-like initializer arg.
- grant MINTER_ROLE/BURNER_ROLE from initializer args.
- mint(to, amount): only MINTER_ROLE, whenNotPaused, within TTL, within 1:1 invariant, within optional per-tx limit, optional allowlist.
- burnFrom(account, amount): only BURNER_ROLE, whenNotPaused. Optionally support user self-burn().
- pause/unpause: only admin.
- _authorizeUpgrade(): onlyRole(DEFAULT_ADMIN_ROLE).
- Events:
  event TokensMinted(address indexed to, uint256 amount, address indexed operator, uint256 totalSupplyAfter, uint256 reserveAfter, uint256 timestamp);
  event TokensBurned(address indexed from, uint256 amount, address indexed operator, uint256 totalSupplyAfter, uint256 timestamp);

Reserve component (VetraReserve or integrated)
- requestReserveUpdate(): payable in LINK if needed. Emits ReserveUpdateRequested.
- _fulfill() from Chainlink Functions sets lastReserveUsd, lastReserveTimestamp, lastReserveNonce. Emits ReserveUpdated.
- view getters: reserveUsd(), reserveAge(), reserveNonce().

SCRIPTS
- scripts/deploy.ts:
  - Load env. Deploy implementation + Proxy with OZ upgrades.
  - Initialize with admin/minter/burner per env.
  - Save addresses to artifacts file (addresses.<network>.json).
- scripts/updateReserve.ts:
  - Trigger Functions request using source code string that fetches RESERVE_API_URL.
  - Use encrypted off-chain secrets for any API keys.
- scripts/verify.ts:
  - Verify implementation via hardhat-verify and OZ upgrades plugin helpers.
- scripts/monitor.ts:
  - Tail events and show human-readable lines.

TEST PLAN (write first)
1) Roles
- Only admin can upgrade/pause.
- Only minter can mint; only burner can burnFrom.
2) Reserve freshness/invariant
- Mint fails if reserve is stale (> TTL).
- Mint fails if supply+amount > reserve.
- Mint passes when fresh and within reserve.
3) Functions flow
- requestReserveUpdate → fulfill mock → ReserveUpdated, fields set, nonce monotonicity enforced.
4) Upgradeability
- Upgrade to VetraV2 that adds a dummy method; state and roles preserved; only admin can upgrade.
5) Limits + allowlist (if enabled)
- Per-tx limit enforced. Allowlist enforced.
6) Events
- TokensMinted/TokensBurned payloads correct.
7) Pausable
- All state-changing ops revert while paused.

HARDHAT CONFIG
- networks.amoy and networks.polygon read via env.ts.
- etherscan.apiKey = POLYGONSCAN_API_KEY (works for both Polygon + Amoy).
- solidity: ^0.8.24 with optimizer 200 runs.

DEPLOY FLOW
# Testnet
- Fund deployer with 3 Amoy POL and 2 test LINK.
- pnpm hardhat run scripts/deploy.ts --network amoy
- pnpm hardhat run scripts/updateReserve.ts --network amoy
- pnpm hardhat test
- pnpm hardhat verify --network amoy <implAddress>
# Mainnet
- Set NODE_ENV=production. Do NOT change any other .env key names.
- pnpm hardhat run scripts/deploy.ts --network polygon
- pnpm hardhat run scripts/updateReserve.ts --network polygon
- pnpm hardhat verify --network polygon <implAddress>

DOCS (README.md)
- Architecture diagram, env schema, scaling math between USD and 18-dec token, Functions workflow, faucets (Amoy POL 3 / LINK 2), operational runbook (how to refresh reserves, monitor events, pause in emergency), and acceptance criteria.

ACCEPTANCE CRITERIA
- All tests pass. Lint passes.
- On Amoy: proxy+impl deployed; reserve set via Functions; mint constrained by reserve; events visible.
- On Polygon: same behavior after toggling ONLY NODE_ENV.
- Etherscan/Polygonscan proxy + implementation verified.
- No secrets in repo. .env.example included.

WORK PLAN (execute step-by-step; produce changelog + next actions after each)
1) Init project, install deps, add .editorconfig, .gitignore, .env.example, config/env.ts.
2) Implement Vetra.sol skeleton with UUPS + roles + pause; compile + unit tests for roles.
3) Add reserve storage, events, invariant checks; tests for TTL/invariant.
4) Integrate Chainlink Functions client; mock fulfill in tests; add script to request update.
5) Add limits/allowlist guards; tests.
6) Write deploy/verify/monitor scripts; deploy to Amoy; verify; run reserve update.
7) Write upgrade test with V2; run.
8) Final docs; produce addresses.amoy.json.
9) Switch NODE_ENV=production and dry-run mainnet config validation without deploying; then document the exact mainnet deploy steps.

Do not skip steps. Keep code consistent with env.ts. Every time you add a new env key, update .env.example and README.md.
